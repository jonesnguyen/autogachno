import os
import logging
import tkinter as tk
from tkinter import ttk, messagebox
from datetime import datetime
import time
import threading

import sys
# Ensure parent directory is on sys.path so we can import the package `app` when running directly
PARENT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if PARENT_DIR not in sys.path:
	sys.path.insert(0, PARENT_DIR)

from app.config import Config, LOGIN_USERNAME
from app.utils.browser import driver, initialize_browser, cleanup, login_process, ensure_driver_and_login
from app.utils.ui_helpers import show_services_form, set_root, get_root, maybe_update_ui

# C·∫•u h√¨nh logging
logging.basicConfig(
	level=logging.INFO,
	format='%(asctime)s - %(levelname)s - %(message)s',
	handlers=[
		logging.FileHandler('app.log', encoding='utf-8'),
		logging.StreamHandler()
	]
)
logger = logging.getLogger(__name__)

# Global variables
root = None
auto_mode_enabled = False
auto_mode_thread = None
auto_mode_stop_flag = False
auto_mode_loop_enabled = False  # Th√™m bi·∫øn cho ch·∫ø ƒë·ªô l·∫∑p
auto_mode_loop_interval = 10  # Kho·∫£ng th·ªùi gian l·∫∑p l·∫°i (gi√¢y)
ui_initialized = False

def initialize_main_ui():
	"""Kh·ªüi t·∫°o UI ch√≠nh m·ªôt l·∫ßn duy nh·∫•t"""
	global root, ui_initialized
	
	if ui_initialized and root:
		return root
		
	if root is None:
		root = tk.Tk()
		root.title("HPK Tool - Viettel Pay Automation")
		root.geometry("500x550") 
		root.option_add("*Font", "Arial 10")
		try:
			root.iconbitmap(Config.ICON_FILE)
		except Exception as e:
			logger.warning(f"Kh√¥ng th·ªÉ t·∫£i icon: {e}")
			pass
		set_root(root)
	
	# Ch·ªâ hi·ªÉn th·ªã form d·ªãch v·ª• m·ªôt l·∫ßn
	if not ui_initialized:
		show_services_form()
		create_auto_mode_controls()
		ui_initialized = True
	
	return root

def find_widget_by_text(parent, widget_type, text_pattern, max_depth=5, current_depth=0):
	"""T√¨m widget theo text pattern v·ªõi exact match ƒë·ªÉ tr√°nh nh·∫ßm v·ªõi auto buttons"""
	if current_depth > max_depth:
		return None
	try:
		for widget in parent.winfo_children():
			if isinstance(widget, widget_type):
				if hasattr(widget, 'cget') and widget.cget('text') == text_pattern:
					return widget
			# Recursively search in child widgets
			result = find_widget_by_text(widget, widget_type, text_pattern, max_depth, current_depth + 1)
			if result:
				return result
	except Exception:
		pass
	return None

def find_combobox_by_values(parent, value_pattern, max_depth=5, current_depth=0):
	"""T√¨m combobox ch·ª©a value pattern v·ªõi gi·ªõi h·∫°n ƒë·ªô s√¢u"""
	if current_depth > max_depth:
		return None
	try:
		for widget in parent.winfo_children():
			if isinstance(widget, tk.ttk.Combobox):
				if hasattr(widget, 'cget') and value_pattern in str(widget.cget('values')):
					return widget
			# Recursively search in child widgets
			result = find_combobox_by_values(widget, value_pattern, max_depth, current_depth + 1)
			if result:
				return result
	except Exception:
		pass
	return None

def wait_for_widget(parent, finder_func, finder_args, timeout=20, poll_interval=0.5):
	"""Ch·ªù widget xu·∫•t hi·ªán v·ªõi timeout"""
	start_time = time.time()
	while time.time() - start_time < timeout:
		widget = finder_func(parent, *finder_args)
		if widget:
			return widget
		maybe_update_ui()
		time.sleep(poll_interval)
	return None

def reset_service_form():
	"""Reset form d·ªãch v·ª• v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu"""
	try:
		r = get_root()
		
		# T√¨m v√† reset combobox d·ªãch v·ª•
		service_combobox = find_combobox_by_values(r, "Tra c·ª©u FTTH")
		if service_combobox:
			service_combobox.set("")  # Clear selection
			maybe_update_ui()
			
		# T√¨m v√† clear c√°c text widgets
		for widget in r.winfo_children():
			if isinstance(widget, tk.Frame):
				for child in widget.winfo_children():
					if isinstance(child, tk.Frame):
						for subchild in child.winfo_children():
							if isinstance(subchild, tk.Text):
								try:
									subchild.delete("1.0", "end")
								except:
									pass
		
		logger.info("üîÑ ƒê√£ reset form d·ªãch v·ª•")
		maybe_update_ui()
		
	except Exception as e:
		logger.error(f"L·ªói reset service form: {e}")

def auto_process_service(service_name):
	"""T·ª± ƒë·ªông x·ª≠ l√Ω m·ªôt d·ªãch v·ª• c·ª• th·ªÉ v·ªõi retry v√† timeout"""
	global auto_mode_stop_flag
	try:
		logger.info(f"ü§ñ B·∫Øt ƒë·∫ßu x·ª≠ l√Ω t·ª± ƒë·ªông: {service_name}")
		
		# C·∫≠p nh·∫≠t status label
		update_auto_mode_status(f"ƒêang x·ª≠ l√Ω: {service_name}")
		
		# Reset form tr∆∞·ªõc khi ch·ªçn d·ªãch v·ª• m·ªõi
		reset_service_form()
		time.sleep(2)
		
		# T√¨m v√† ch·ªçn d·ªãch v·ª• trong combobox v·ªõi ch·ªù
		r = get_root()
		service_combobox = wait_for_widget(
			r, 
			find_combobox_by_values, 
			(service_name,)
		)
		
		if not service_combobox:
			logger.error(f"Kh√¥ng t√¨m th·∫•y combobox d·ªãch v·ª• cho: {service_name}")
			return False
			
		# Ch·ªçn d·ªãch v·ª•
		logger.info(f"üéØ ƒêang ch·ªçn d·ªãch v·ª•: {service_name}")
		service_combobox.set(service_name)
		service_combobox.event_generate('<<ComboboxSelected>>')
		maybe_update_ui()
		time.sleep(3)  # ƒê·ª£i UI c·∫≠p nh·∫≠t v√† form d·ªãch v·ª• ƒë∆∞·ª£c load
		
		if auto_mode_stop_flag:
			return False
			
		# Ch·ªù n√∫t "Get d·ªØ li·ªáu" xu·∫•t hi·ªán
		get_data_button = wait_for_widget(
			r,
			find_widget_by_text,
			(tk.ttk.Button, "Get d·ªØ li·ªáu")
		)
		if not get_data_button:
			logger.error("Kh√¥ng t√¨m th·∫•y n√∫t 'Get d·ªØ li·ªáu' sau khi load form")
			return False
			
		# B·∫•m n√∫t Get d·ªØ li·ªáu
		logger.info("üîÑ ƒêang l·∫•y d·ªØ li·ªáu...")
		update_auto_mode_status(f"ƒêang l·∫•y d·ªØ li·ªáu: {service_name}")
		get_data_button.invoke()
		maybe_update_ui()
		time.sleep(5)  # ƒê·ª£i d·ªØ li·ªáu load l√¢u h∆°n
		
		if auto_mode_stop_flag:
			return False
		
		# *** KI·ªÇM TRA DATABASE TR∆Ø·ªöC KHI KI·ªÇM TRA TEXT WIDGET ***
		# Ki·ªÉm tra xem d·ªØ li·ªáu t·ª´ database c√≥ r·ªóng kh√¥ng
		try:
			from ..db import db_fetch_service_data
			service_map = {
				"Tra c·ª©u FTTH": "tra_cuu_ftth",
				"G·∫°ch ƒëi·ªán EVN": "gach_dien_evn", 
				"N·∫°p ti·ªÅn ƒëa m·∫°ng": "nap_tien_da_mang",
				"N·∫°p ti·ªÅn m·∫°ng Viettel": "nap_tien_mang_viettel",
				"Thanh to√°n TV - Internet": "thanh_toan_tv_internet",
				"Tra c·ª©u n·ª£ thu√™ bao tr·∫£ sau": "tra_cuu_no_thue_bao_tra_sau"
			}
			
			db_service_key = service_map.get(service_name)
			if db_service_key:
				db_data = db_fetch_service_data(db_service_key)
				if db_data:
					subscriber_codes = db_data.get("subscriber_codes", [])
					code_order_map = db_data.get("code_order_map", [])
					
					# Ki·ªÉm tra n·∫øu c·∫£ subscriber_codes v√† code_order_map ƒë·ªÅu r·ªóng
					if not subscriber_codes and not code_order_map:
						logger.warning(f"‚ö†Ô∏è Database tr·∫£ v·ªÅ d·ªØ li·ªáu r·ªóng cho {service_name}")
						logger.info(f"   - subscriber_codes: {subscriber_codes}")
						logger.info(f"   - code_order_map: {code_order_map}")
						update_auto_mode_status(f"‚ö†Ô∏è B·ªè qua: {service_name} (DB r·ªóng)")
						return True  # B·ªè qua v√† chuy·ªÉn sang d·ªãch v·ª• ti·∫øp theo
		except Exception as e:
			logger.warning(f"Kh√¥ng th·ªÉ ki·ªÉm tra d·ªØ li·ªáu database: {e}")
			# Ti·∫øp t·ª•c ki·ªÉm tra text widget nh∆∞ b√¨nh th∆∞·ªùng
			
		# T√¨m text widget ch·ª©a d·ªØ li·ªáu ƒë·ªÉ ki·ªÉm tra
		text_widget = None
		for frame in r.winfo_children():
			if isinstance(frame, tk.Frame):
				for child in frame.winfo_children():
					if isinstance(child, tk.Frame):
						for subchild in child.winfo_children():
							if isinstance(subchild, tk.Text) and subchild.cget('bg') != "#ccc":
								text_widget = subchild
								break
						if text_widget:
							break
				if text_widget:
					break
		
		if not text_widget:
			logger.error("Kh√¥ng t√¨m th·∫•y text widget ƒë·ªÉ ki·ªÉm tra d·ªØ li·ªáu")
			return False
		
		# Ki·ªÉm tra d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c load ch∆∞a v·ªõi retry
		data_loaded = False
		data_content = ""
		max_retries = 3  # TƒÉng retry
		for retry in range(max_retries):
			try:
				data_content = text_widget.get("1.0", "end-1c").strip()
				if data_content and len(data_content.splitlines()) > 0:
					# Ki·ªÉm tra xem c√≥ ph·∫£i d·ªØ li·ªáu th·∫≠t kh√¥ng (kh√¥ng ph·∫£i th√¥ng b√°o l·ªói)
					lines = data_content.splitlines()
					valid_lines = [line.strip() for line in lines if line.strip() and not line.strip().startswith("Kh√¥ng c√≥") and not line.strip().startswith("Error")]
					
					if valid_lines:
						data_loaded = True
						logger.info(f"‚úÖ D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c load: {len(valid_lines)} d√≤ng h·ª£p l·ªá")
						break
					else:
						logger.warning(f"‚ö†Ô∏è D·ªØ li·ªáu load nh∆∞ng kh√¥ng h·ª£p l·ªá ho·∫∑c r·ªóng: {data_content[:100]}...")
						if retry >= max_retries - 3:  # Trong 3 l·∫ßn cu·ªëi, ki·ªÉm tra k·ªπ h∆°n
							break
				else:
					logger.info(f"‚è≥ ƒê·ª£i d·ªØ li·ªáu load... (l·∫ßn {retry + 1}/{max_retries})")
				time.sleep(1)
				maybe_update_ui()
			except Exception as e:
				logger.warning(f"L·ªói ki·ªÉm tra d·ªØ li·ªáu l·∫ßn {retry + 1}: {e}")
				time.sleep(1)
		
		# Ki·ªÉm tra cu·ªëi c√πng xem c√≥ d·ªØ li·ªáu kh√¥ng
		if not data_loaded:
			logger.warning(f"‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu cho d·ªãch v·ª• {service_name} - B·ªè qua v√† chuy·ªÉn sang d·ªãch v·ª• ti·∫øp theo")
			update_auto_mode_status(f"‚ö†Ô∏è B·ªè qua: {service_name} (Kh√¥ng c√≥ d·ªØ li·ªáu)")
			return True  # Return True ƒë·ªÉ ti·∫øp t·ª•c v·ªõi d·ªãch v·ª• ti·∫øp theo, kh√¥ng d·ª´ng to√†n b·ªô auto mode
		
		# Ki·ªÉm tra l·∫°i n·ªôi dung d·ªØ li·ªáu m·ªôt l·∫ßn n·ªØa ƒë·ªÉ ƒë·∫£m b·∫£o
		final_data_content = text_widget.get("1.0", "end-1c").strip()
		if not final_data_content:
			logger.warning(f"‚ö†Ô∏è D·ªØ li·ªáu r·ªóng cho d·ªãch v·ª• {service_name} - B·ªè qua")
			update_auto_mode_status(f"‚ö†Ô∏è B·ªè qua: {service_name} (D·ªØ li·ªáu r·ªóng)")
			return True
			
		# Ki·ªÉm tra xem c√≥ ph·∫£i th√¥ng b√°o l·ªói kh√¥ng
		error_keywords = ["Kh√¥ng c√≥", "Error", "L·ªói", "kh√¥ng t√¨m th·∫•y", "empty", "null"]
		if any(keyword.lower() in final_data_content.lower() for keyword in error_keywords):
			logger.warning(f"‚ö†Ô∏è D·ªØ li·ªáu ch·ª©a th√¥ng b√°o l·ªói cho d·ªãch v·ª• {service_name}: {final_data_content[:100]}...")
			update_auto_mode_status(f"‚ö†Ô∏è B·ªè qua: {service_name} (D·ªØ li·ªáu l·ªói)")
			return True
			
		# C·∫≠p nh·∫≠t data_content ƒë·ªÉ s·ª≠ d·ª•ng ·ªü ph·∫ßn sau
		data_content = final_data_content
		
		# Hi·ªÉn th·ªã th√¥ng tin d·ªØ li·ªáu ƒë√£ load
		try:
			if data_content:
				lines = data_content.split('\n')
				valid_lines = [line.strip() for line in lines if line.strip()]
				logger.info(f"üìä S·ªë l∆∞·ª£ng m√£ c·∫ßn x·ª≠ l√Ω: {len(valid_lines)}")
				for i, line in enumerate(valid_lines[:3], 1):  # Hi·ªÉn th·ªã 3 m√£ ƒë·∫ßu ti√™n
					if '|' in line:
						code, order_id = line.split('|', 1)
						logger.info(f"   - M√£ {i}: {code.strip()} (Order: {order_id.strip()})")
					else:
						logger.info(f"   - M√£ {i}: {line.strip()}")
		except Exception as e:
			logger.warning(f"L·ªói hi·ªÉn th·ªã d·ªØ li·ªáu sample: {e}")
		
		if auto_mode_stop_flag:
			return False
		
		# *** IMPROVED: T√¨m t·∫•t c·∫£ n√∫t "B·∫Øt ƒë·∫ßu" v√† debug ch√∫ng ***
		logger.info("üîç T√¨m ki·∫øm c√°c n√∫t 'B·∫Øt ƒë·∫ßu'...")
		all_start_buttons = []
		
		def find_all_start_buttons(parent, depth=0):
			if depth > 10:  # Gi·ªõi h·∫°n ƒë·ªô s√¢u
				return
			try:
				for widget in parent.winfo_children():
					if isinstance(widget, tk.ttk.Button):
						if hasattr(widget, 'cget') and widget.cget('text') == "B·∫Øt ƒë·∫ßu":
							style = widget.cget('style') or ""
							logger.info(f"   - T√¨m th·∫•y n√∫t 'B·∫Øt ƒë·∫ßu': style='{style}', state='{widget.cget('state')}'")
							all_start_buttons.append((widget, style))
					# T√¨m ƒë·ªá quy trong widget con
					find_all_start_buttons(widget, depth + 1)
			except Exception as e:
				pass
		
		find_all_start_buttons(r)
		
		if not all_start_buttons:
			logger.error("‚ùå Kh√¥ng t√¨m th·∫•y n√∫t 'B·∫Øt ƒë·∫ßu' n√†o sau khi load d·ªØ li·ªáu")
			return False
		
		# T√¨m n√∫t c√≥ style "Blue.TButton" ho·∫∑c l·∫•y n√∫t ƒë·∫ßu ti√™n
		start_button = None
		for btn, style in all_start_buttons:
			if style == "Blue.TButton":
				start_button = btn
				logger.info(f"‚úÖ T√¨m th·∫•y n√∫t 'B·∫Øt ƒë·∫ßu' c√≥ style 'Blue.TButton'")
				break
		
		if not start_button and all_start_buttons:
			# N·∫øu kh√¥ng t√¨m th·∫•y Blue.TButton, l·∫•y n√∫t ƒë·∫ßu ti√™n v√† log warning
			start_button = all_start_buttons[0][0]
			logger.warning(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y n√∫t 'Blue.TButton', s·ª≠ d·ª•ng n√∫t ƒë·∫ßu ti√™n: style='{all_start_buttons[0][1]}'")
		
		if not start_button:
			logger.error("‚ùå Kh√¥ng c√≥ n√∫t 'B·∫Øt ƒë·∫ßu' kh·∫£ d·ª•ng")
			return False
		
		# B·∫•m n√∫t B·∫Øt ƒë·∫ßu
		logger.info("‚ñ∂Ô∏è ƒêang b·∫Øt ƒë·∫ßu x·ª≠ l√Ω...")
		update_auto_mode_status(f"ƒêang x·ª≠ l√Ω d·ªØ li·ªáu: {service_name}")
		start_button.invoke()
		maybe_update_ui()
		
		# Theo d√µi ti·∫øn ƒë·ªô x·ª≠ l√Ω b·∫±ng c√°ch ki·ªÉm tra text widget "ƒê√£ x·ª≠ l√Ω"
		processed_widget = None
		for frame in r.winfo_children():
			if isinstance(frame, tk.Frame):
				for child in frame.winfo_children():
					if isinstance(child, tk.Frame):
						for subchild in child.winfo_children():
							if isinstance(subchild, tk.Text) and subchild.cget('bg') == "#ccc":
								processed_widget = subchild
								break
						if processed_widget:
							break
				if processed_widget:
					break
		
		if not processed_widget:
			logger.warning("Kh√¥ng t√¨m th·∫•y processed text widget ƒë·ªÉ theo d√µi ti·∫øn ƒë·ªô")
		
		# Ch·ªù x·ª≠ l√Ω xong v·ªõi timeout 300 gi√¢y (5 ph√∫t m·ªói d·ªãch v·ª•)
		processing_timeout = 300
		start_time = time.time()
		last_line_count = 0
		stuck_counter = 0
		max_stuck = 10  # N·∫øu kh√¥ng thay ƒë·ªïi trong 10 l·∫ßn check, coi nh∆∞ xong ho·∫∑c l·ªói
		
		while time.time() - start_time < processing_timeout:
			if auto_mode_stop_flag:
				return False
				
			try:
				if processed_widget:
					processed_content = processed_widget.get("1.0", "end-1c").strip()
					line_count = len(processed_content.splitlines()) if processed_content else 0
					total_lines = len(data_content.splitlines())
					
					if line_count > last_line_count:
						logger.info(f"üìà Ti·∫øn ƒë·ªô: {line_count} / {total_lines} (~{int(line_count / total_lines * 100) if total_lines > 0 else 0}%)")
						last_line_count = line_count
						stuck_counter = 0
					else:
						stuck_counter += 1
						if stuck_counter >= max_stuck:
							logger.info(f"‚úÖ X·ª≠ l√Ω c√≥ th·ªÉ ƒë√£ ho√†n th√†nh (kh√¥ng thay ƒë·ªïi trong {max_stuck * 2} gi√¢y)")
							break
					
					if line_count >= total_lines:
						logger.info(f"‚úÖ ƒê√£ x·ª≠ l√Ω xong t·∫•t c·∫£: {line_count} m·ª•c")
						break
				else:
					# Kh√¥ng c√≥ processed widget, ch·ªâ ƒë·ª£i m·ªôt th·ªùi gian c·ªë ƒë·ªãnh
					time.sleep(10)
					break
			except Exception as e:
				logger.warning(f"L·ªói theo d√µi ti·∫øn ƒë·ªô: {e}")
			
			maybe_update_ui()
			time.sleep(2)  # Check m·ªói 2 gi√¢y
		
		if time.time() - start_time >= processing_timeout:
			logger.warning(f"‚ö†Ô∏è Timeout x·ª≠ l√Ω cho {service_name}")
			return False
		
		logger.info(f"üéâ Ho√†n th√†nh d·ªãch v·ª•: {service_name}")
		update_auto_mode_status(f"Ho√†n th√†nh: {service_name}")
		time.sleep(3)  # ƒê·ª£i m·ªôt ch√∫t tr∆∞·ªõc khi sang d·ªãch v·ª• ti·∫øp theo
		return True
		
	except Exception as e:
		logger.error(f"‚ùå L·ªói x·ª≠ l√Ω d·ªãch v·ª• {service_name}: {e}")
		update_auto_mode_status(f"‚ùå L·ªói: {service_name}")
		return False
	
def auto_cron_worker():
	"""Worker thread cho auto mode - x·ª≠ l√Ω tu·∫ßn t·ª± 6 d·ªãch v·ª•"""
	global auto_mode_stop_flag, auto_mode_loop_enabled, auto_mode_loop_interval
	try:
		while auto_mode_loop_enabled and not auto_mode_stop_flag:
			logger.info(f"üîÑ B·∫Øt ƒë·∫ßu chu k·ª≥ auto mode m·ªõi (l·∫∑p l·∫°i m·ªói {auto_mode_loop_interval} gi√¢y)")
			
			services = [
				"Tra c·ª©u FTTH",
				"G·∫°ch ƒëi·ªán EVN",
				"N·∫°p ti·ªÅn ƒëa m·∫°ng",
				"N·∫°p ti·ªÅn m·∫°ng Viettel",
				"Thanh to√°n TV - Internet",
				"Tra c·ª©u n·ª£ thu√™ bao tr·∫£ sau"
			]
			
			completed_services = 0
			skipped_services = 0
			failed_services = 0
			
			for service in services:
				if auto_mode_stop_flag:
					logger.info("üõë Auto mode b·ªã d·ª´ng b·ªüi ng∆∞·ªùi d√πng")
					break
					
				logger.info(f"üîÑ B·∫Øt ƒë·∫ßu x·ª≠ l√Ω d·ªãch v·ª• {completed_services + skipped_services + failed_services + 1}/{len(services)}: {service}")
				success = auto_process_service(service)
				
				if success:
					completed_services += 1
					logger.info(f"‚úÖ Ho√†n th√†nh d·ªãch v·ª•: {service}")
				else:
					# Ki·ªÉm tra xem c√≥ ph·∫£i b·ªè qua hay th·∫≠t s·ª± l·ªói
					current_status = ""
					try:
						r = get_root()
						auto_frame = None
						for widget in r.winfo_children():
							if hasattr(widget, 'winfo_name') and 'auto_frame' in str(widget.winfo_name()):
								auto_frame = widget
								break
						if auto_frame and hasattr(auto_frame, 'status_label'):
							current_status = auto_frame.status_label.cget('text')
					except:
						pass
						
					if "B·ªè qua" in current_status:
						skipped_services += 1
						logger.info(f"‚ö†Ô∏è B·ªè qua d·ªãch v·ª•: {service} (Kh√¥ng c√≥ d·ªØ li·ªáu)")
					else:
						failed_services += 1
						logger.error(f"‚ùå L·ªói x·ª≠ l√Ω d·ªãch v·ª•: {service}")
						# C√≥ th·ªÉ ch·ªçn ti·∫øp t·ª•c ho·∫∑c d·ª´ng ·ªü ƒë√¢y
						# break  # Uncomment n·∫øu mu·ªën d·ª´ng khi g·∫∑p l·ªói th·∫≠t s·ª±
			
			# Th·ªëng k√™ cu·ªëi c√πng
			total_processed = completed_services + skipped_services + failed_services
			logger.info(f"üìä Th·ªëng k√™ Auto Mode:")
			logger.info(f"   - T·ªïng d·ªãch v·ª•: {len(services)}")
			logger.info(f"   - Ho√†n th√†nh: {completed_services}")
			logger.info(f"   - B·ªè qua: {skipped_services}")
			logger.info(f"   - L·ªói: {failed_services}")
			
			if not auto_mode_stop_flag:
				if failed_services == 0:
					logger.info("üèÅ Ho√†n th√†nh t·∫•t c·∫£ d·ªãch v·ª• trong auto mode")
					update_auto_mode_status(f"üèÅ Ho√†n th√†nh: {completed_services}, B·ªè qua: {skipped_services}")
				else:
					logger.info(f"‚ö†Ô∏è Auto mode ho√†n th√†nh v·ªõi {failed_services} l·ªói")
					update_auto_mode_status(f"‚ö†Ô∏è Ho√†n th√†nh: {completed_services}, L·ªói: {failed_services}")
			else:
				logger.info("üõë Auto mode ƒë√£ b·ªã d·ª´ng gi·ªØa ch·ª´ng")
				update_auto_mode_status(f"üõë D·ª´ng: {total_processed}/{len(services)}")
				break
			
			# Ki·ªÉm tra xem c√≥ c·∫ßn l·∫∑p l·∫°i kh√¥ng
			if auto_mode_loop_enabled and not auto_mode_stop_flag:
				logger.info(f"‚è∞ Ch·ªù {auto_mode_loop_interval} gi√¢y tr∆∞·ªõc khi l·∫∑p l·∫°i...")
				update_auto_mode_status(f"‚è∞ Ch·ªù {auto_mode_loop_interval}s ƒë·ªÉ l·∫∑p l·∫°i...")
				
				# Ch·ªù v·ªõi ki·ªÉm tra stop flag m·ªói gi√¢y
				for i in range(auto_mode_loop_interval):
					if auto_mode_stop_flag:
						break
					time.sleep(1)
					maybe_update_ui()
				
				if auto_mode_stop_flag:
					break
					
				logger.info("üîÑ B·∫Øt ƒë·∫ßu chu k·ª≥ auto mode ti·∫øp theo...")
			else:
				break
	
	except Exception as e:
		logger.error(f"‚ùå L·ªói trong auto cron worker: {e}")
		update_auto_mode_status("‚ùå L·ªói h·ªá th·ªëng")
	finally:
		# Reset auto mode
		global auto_mode_enabled
		auto_mode_enabled = False
		update_auto_mode_ui()

def start_auto_mode():
	"""B·∫Øt ƒë·∫ßu ch·∫ø ƒë·ªô t·ª± ƒë·ªông"""
	global auto_mode_enabled, auto_mode_thread, auto_mode_stop_flag, auto_mode_loop_enabled
	
	if auto_mode_enabled:
		logger.warning("Auto mode ƒë√£ ƒëang ch·∫°y!")
		return
		
	auto_mode_enabled = True
	auto_mode_stop_flag = False
	auto_mode_loop_enabled = True  # B·∫≠t ch·∫ø ƒë·ªô l·∫∑p t·ª± ƒë·ªông
	
	# Kh·ªüi t·∫°o thread cho auto mode
	auto_mode_thread = threading.Thread(target=auto_cron_worker, daemon=True)
	auto_mode_thread.start()
	
	logger.info("üöÄ ƒê√£ b·∫Øt ƒë·∫ßu Auto Mode (l·∫∑p l·∫°i m·ªói 10 gi√¢y)")
	update_auto_mode_status("üöÄ ƒê√£ b·∫Øt ƒë·∫ßu Auto Mode (l·∫∑p l·∫°i m·ªói 10s)")
	update_auto_mode_ui()

def stop_auto_mode():
	"""D·ª´ng ch·∫ø ƒë·ªô t·ª± ƒë·ªông"""
	global auto_mode_enabled, auto_mode_stop_flag, auto_mode_loop_enabled
	
	auto_mode_stop_flag = True
	auto_mode_enabled = False
	auto_mode_loop_enabled = False  # T·∫Øt ch·∫ø ƒë·ªô l·∫∑p t·ª± ƒë·ªông
	
	logger.info("üõë ƒê√£ d·ª´ng Auto Mode")
	update_auto_mode_status("üõë ƒê√£ d·ª´ng Auto Mode")
	update_auto_mode_ui()
	
	# ƒê·ª£i thread k·∫øt th√∫c
	if auto_mode_thread and auto_mode_thread.is_alive():
		auto_mode_thread.join(timeout=5)  # TƒÉng timeout join

def update_auto_mode_status(status_text):
	"""C·∫≠p nh·∫≠t status label c·ªßa auto mode"""
	try:
		r = get_root()
		if not r:
			return
			
		# T√¨m frame ch·ª©a auto mode controls
		auto_frame = None
		for widget in r.winfo_children():
			if hasattr(widget, 'winfo_name') and 'auto_frame' in str(widget.winfo_name()):
				auto_frame = widget
				break
				
		if auto_frame and hasattr(auto_frame, 'status_label'):
			auto_frame.status_label.config(text=status_text, fg="blue")
			maybe_update_ui()
	except Exception as e:
		logger.error(f"L·ªói c·∫≠p nh·∫≠t auto mode status: {e}")

def update_auto_mode_ui():
	"""C·∫≠p nh·∫≠t UI theo tr·∫°ng th√°i auto mode"""
	try:
		r = get_root()
		if not r:
			return
			
		# T√¨m frame ch·ª©a c√°c n√∫t auto mode
		auto_frame = None
		for widget in r.winfo_children():
			if hasattr(widget, 'winfo_name') and 'auto_frame' in str(widget.winfo_name()):
				auto_frame = widget
				break
				
		if auto_frame:
			for widget in auto_frame.winfo_children():
				if isinstance(widget, tk.ttk.Button):
					if "B·∫Øt ƒë·∫ßu Auto" in widget.cget('text'):
						widget.config(state="disabled" if auto_mode_enabled else "normal")
					elif "D·ª´ng Auto" in widget.cget('text'):
						widget.config(state="normal" if auto_mode_enabled else "disabled")
			
			# C·∫≠p nh·∫≠t status label
			if hasattr(auto_frame, 'status_label'):
				if auto_mode_enabled:
					if auto_mode_loop_enabled:
						auto_frame.status_label.config(text="üîÑ ƒêang ch·∫°y (l·∫∑p l·∫°i m·ªói 10s)...", fg="orange")
					else:
						auto_frame.status_label.config(text="üîÑ ƒêang ch·∫°y...", fg="orange")
				else:
					auto_frame.status_label.config(text="S·∫µn s√†ng", fg="green")
					
	except Exception as e:
		logger.error(f"L·ªói c·∫≠p nh·∫≠t auto mode UI: {e}")

def create_auto_mode_controls():
	"""T·∫°o c√°c ƒëi·ªÅu khi·ªÉn cho auto mode"""
	try:
		r = get_root()
		if not r:
			return
		
		# Ki·ªÉm tra xem ƒë√£ t·ªìn t·∫°i auto_frame ch∆∞a
		auto_frame_exists = False
		for widget in r.winfo_children():
			if hasattr(widget, 'winfo_name') and 'auto_frame' in str(widget.winfo_name()):
				auto_frame_exists = True
				break
		
		if auto_frame_exists:
			return  # ƒê√£ t·∫°o r·ªìi, kh√¥ng t·∫°o l·∫°i
		
		# T·∫°o frame cho auto controls
		auto_frame = tk.Frame(r, name="auto_frame")
		auto_frame.pack(side="top", padx=6, pady=6, fill="x")
		
		# Label
		tk.Label(auto_frame, text="ü§ñ Ch·∫ø ƒë·ªô t·ª± ƒë·ªông:", font=("Arial", 10, "bold")).pack(side="left")
		
		# N√∫t b·∫Øt ƒë·∫ßu auto
		start_auto_btn = tk.ttk.Button(
			auto_frame, 
			text="üöÄ B·∫Øt ƒë·∫ßu Auto Mode", 
			command=start_auto_mode
		)
		start_auto_btn.pack(side="left", padx=5)
		
		# N√∫t d·ª´ng auto
		stop_auto_btn = tk.ttk.Button(
			auto_frame, 
			text="üõë D·ª´ng Auto Mode", 
			command=stop_auto_mode,
			state="disabled"
		)
		stop_auto_btn.pack(side="left", padx=5)
		
		# Th√¥ng tin v·ªÅ ch·∫ø ƒë·ªô l·∫∑p
		loop_info_label = tk.Label(
			auto_frame, 
			text="‚è∞ T·ª± ƒë·ªông l·∫∑p l·∫°i m·ªói 10 gi√¢y", 
			fg="purple", 
			font=("Arial", 8, "italic")
		)
		loop_info_label.pack(side="left", padx=10)
		
		# Status label v·ªõi m√†u s·∫Øc
		status_label = tk.Label(auto_frame, text="S·∫µn s√†ng", fg="green", font=("Arial", 9, "bold"))
		status_label.pack(side="right", padx=10)
		
		# L∆∞u reference ƒë·∫øn status label ƒë·ªÉ c√≥ th·ªÉ c·∫≠p nh·∫≠t sau
		auto_frame.status_label = status_label
		
		# Separator
		separator = tk.ttk.Separator(r, orient="horizontal")
		separator.pack(fill="x", padx=6, pady=3)
		
	except Exception as e:
		logger.error(f"L·ªói t·∫°o auto mode controls: {e}")

def main():
	"""H√†m main - ch·ªâ kh·ªüi t·∫°o m·ªôt l·∫ßn"""
	global driver, ui_initialized
	
	try:
		# Kh·ªüi t·∫°o UI ch√≠nh
		initialize_main_ui()
		
		# Kh·ªüi t·∫°o tr√¨nh duy·ªát v√† ƒëƒÉng nh·∫≠p t·ª± ƒë·ªông b·∫±ng t√†i kho·∫£n m·∫∑c ƒë·ªãnh
		ensure_driver_and_login()
		try:
			login_process()
		except Exception:
			pass
			
	except Exception as e:
		logger.error(f"L·ªói kh·ªüi t·∫°o: {e}")

if __name__ == "__main__":
	try:
		main()
		
		def on_closing():
			global auto_mode_stop_flag, auto_mode_loop_enabled
			auto_mode_stop_flag = True
			auto_mode_loop_enabled = False
			cleanup()
			if root:
				root.destroy()
		
		if root:
			root.protocol("WM_DELETE_WINDOW", on_closing)
			root.mainloop()
	except Exception as e:
		logger.error(f"L·ªói ch√≠nh: {e}")
		#messagebox.showerror("L·ªói", f"L·ªói kh·ªüi ƒë·ªông ·ª©ng d·ª•ng: {e}")
	finally:
		cleanup()